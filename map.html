<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body style="margin: 0; overflow: hidden">
    <div id="scale"></div>
    <div style="position: fixed; height: 100vh; width: 100vw; left: 0; top: 0">
      <canvas></canvas>
    </div>
  </body>
  <script>
    const getCoordinate = (e, key) =>
      e[key] ?? (e.changedTouches || e.touches || [])[0][key];
    //fetch("gzdt.json")
    var fn = (body) =>
      // fetch("https://z.overpass-api.de/api/interpreter", {
      //   method: "POST",
      //   body,
      //   headers: { "Content-Type": "application/x-www-form-urlencoded" },
      // })
      fetch("Guangzhou Metro.json")
        .then((a) => a.text())
        .then((text) => {
          const { elements } = JSON.parse(
            text.replace(
              /"(lat|lon)": (\d+\.\d+)/g,
              (_, a, b) => `"${a}":"${b}"`
            )
          );

          const node = new Map();
          const way = new Map();
          const relation = new Map();
          let mainLat;
          let mainLon;
          const getZB = (lat) => {
            const o = lat.split(".");
            o[0] = Number(o[0]);
            o[1] = Number(o[1].padEnd(7, "0"));
            return o;
          };
          const readTag = (obj, tagName, attributes) => {
            switch (tagName) {
              case "tag":
                obj[attributes.k.value] = attributes.v.value;
                return;
              case "member":
              case "nd":
                const type = attributes?.type?.value || "node";
                if (!(type in obj)) {
                  obj[type] = [];
                }
                obj[type].push(Number(attributes.ref.value));
                return;
            }
          };
          for (const ele of elements) {
            if (!ele.id && !ele.ref) {
              continue;
            }
            const obj = ele.tags || {};
            //   for (const child of children) {
            //     readTag(obj, child.tagName, child.attributes);
            //   }
            switch (ele.type) {
              case "node":
                if (!ele.lat || !ele.lon) {
                  break;
                }
                const lat = getZB(ele.lat);
                const lon = getZB(ele.lon);
                if (mainLat === undefined && mainLon === undefined) {
                  mainLat = lat[0];
                  mainLon = lon[0];
                }
                obj.lat = (lat[0] - mainLat) * 1e7 + lat[1];
                obj.lon = (lon[0] - mainLon) * 1e7 + lon[1];
                node.set(ele.id, obj);
                break;
              case "way":
                obj.node = ele.nodes;
                way.set(ele.id, obj);
                break;
              case "relation":
                ele.members.forEach(({ type, ref }) => {
                  if (!obj[type]) {
                    obj[type] = [];
                  }
                  obj[type].push(ref);
                });
                relation.set(ele.id, obj);
                break;
            }
          }
          const o = [...relation.values()].filter(
            ({ route }) => route === "subway" //||
            // route === "tram" ||
            // route === "railway"
            //  route === "train"
          );
          o.forEach((v) => {
            if (v.node && !v.nodeObj) {
              v.nodeObj = v.node.map(node.get.bind(node)).filter((a) => a);
            }
            if (v.way && !v.wayObj) {
              v.wayObj = v.way.map(way.get.bind(way)).filter((a) => a);
              v.wayObj.forEach((a) => {
                if (a.node && !a.nodeObj) {
                  a.nodeObj = a.node.map(node.get.bind(node)).filter((a) => a);
                }
              });
            }
          });
          return o;
        })
        .then((lineData) => {
          let minLat = Infinity;
          let minLon = Infinity;
          let maxLat = 0;
          let maxLon = 0;
          // a.map(({node,way})=>[...node,...way.map(({node})=>node)]).flat()
          lineData
            .map(({ nodeObj, wayObj }) => [
              ...(nodeObj || []),
              ...(wayObj || []).map(({ nodeObj }) => nodeObj).flat(),
            ])
            .flat()
            .forEach(({ lat, lon }) => {
              if (lat > maxLat) {
                maxLat = lat;
              }
              if (lon > maxLon) {
                maxLon = lon;
              }
              if (lat < minLat) {
                minLat = lat;
              }
              if (lon < minLon) {
                minLon = lon;
              }
            });
          //  console.log(minLat,maxLat,maxLat-minLat,minLon,maxLon,maxLon-minLon)
          const canvas = document.getElementsByTagName("canvas")[0];
          const context = canvas.getContext("2d");
          const height = (canvas.height = canvas.parentNode.clientHeight);
          const width = (canvas.width = canvas.parentNode.clientWidth);
          const rawHeight = maxLat - minLat;
          const rawWidth = maxLon - minLon;

          const ratio = Math.min(
            (height - 20) / rawHeight,
            (width - 20) / rawWidth
          );

          let scale = 1;
          let renderScale = ratio * scale;
          let posX = (width - ratio * rawWidth) / 2;
          let posY = (height - ratio * rawHeight) / 2;

          document.getElementById("scale").innerHTML = scale * 100 + "%";
          const getXY = (lat, lon) => [
            (lon - minLon) * renderScale + posX,
            (maxLat - lat) * renderScale + posY,
          ];

          ((X, Y) => {
            const downFn = (e) => {
              X = getCoordinate(e, "clientX") - posX;
              Y = getCoordinate(e, "clientY") - posY;
              window.addEventListener("mousemove", moveFn);
              window.addEventListener("mouseup", upFn);
              window.addEventListener("touchmove", moveFn);
              window.addEventListener("touchend", upFn);
            };
            const moveFn = (e) => {
              e.stopPropagation();
              e.preventDefault();
              posX = getCoordinate(e, "clientX") - X;
              posY = getCoordinate(e, "clientY") - Y;
              draw();
            };
            const upFn = (e) => {
              window.removeEventListener("mousemove", moveFn);
              window.removeEventListener("mouseup", upFn);
              window.removeEventListener("touchmove", moveFn);
              window.removeEventListener("touchend", upFn);
            };
            canvas.addEventListener("mousedown", downFn);
            canvas.addEventListener("touchstart", downFn);
          })(0, 0);

          canvas.onwheel = ({ deltaY, clientX, clientY }) => {
            clientX -= posX;
            clientY -= posY;
            if (deltaY < 0) {
              posX -= clientX;
              posY -= clientY;
              scale *= 2;
            } else {
              if (scale <= 1) {
                return;
              }
              scale /= 2;
              posX += clientX / 2;
              posY += clientY / 2;
            }
            renderScale = ratio * scale;
            document.getElementById("scale").innerHTML = scale * 100 + "%";
            draw();
          };

          const draw = () => {
            context.clearRect(0, 0, width, height);
            // 轨道宽度比例
            context.lineWidth = Math.max(1, renderScale * 143.5);
            const pointSize = Math.max(1, renderScale * 500);
            const textSet = new Set();
            for (const { wayObj, nodeObj, colour } of lineData) {
              const nodeMap = new Map();
              for (const { nodeObj } of wayObj || []) {
                if (nodeObj.length < 2) {
                  continue;
                }
                context.beginPath();
                context.strokeStyle = colour || "#000";
                let isStart = true;
                for (const { lat, lon, name } of nodeObj) {
                  (isStart ? context.moveTo : context.lineTo).apply(
                    context,
                    getXY(lat, lon)
                  );
                  isStart = false;
                  if (name) {
                    nodeMap.set(`${lat},${lon}`, { lat, lon, name });
                  }
                }
                context.stroke();
              }
              for (const { lat, lon, name } of nodeObj || []) {
                if (name) {
                  nodeMap.set(`${lat},${lon}`, { lat, lon, name });
                }
              }
              if (renderScale > 0.0002) {
                for (const [k, { lat, lon, name }] of nodeMap) {
                  context.beginPath();
                  context.arc(...getXY(lat, lon), pointSize, 0, 2 * Math.PI);
                  context.fillStyle = "#ff0"; //设置填充颜色
                  context.fill(); //开始填充
                  if (renderScale > 0.0005 && !textSet.has(name)) {
                    context.fillStyle = "#000"; //设置填充颜色
                    context.font = "16px serif";
                    context.fillText(name, ...getXY(lat, lon));
                    textSet.add(name);
                  }
                  context.stroke();
                }
              }
            }
            //   console.log(...a);
          };
          draw();
        });
    fn(`[out:json]
;
relation
  ["network"="广州地铁"];
(
  way(r);
  node(w);
  way(bn);
  relation(bw);
);
out;`);
  </script>
</html>
